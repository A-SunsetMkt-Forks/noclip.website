
// Source "Studio" models, which seem to be named because of their original ties to 3D Studio Max
// https://developer.valvesoftware.com/wiki/Studiomodel

import ArrayBufferSlice from "../ArrayBufferSlice";
import { GfxDevice } from "../gfx/platform/GfxPlatform";
import { assert, readString, nArray } from "../util";
import { SourceFileSystem, SourceRenderContext } from "./Main";
import { AABB } from "../Geometry";

// Encompasses the MDL, VVD & VTX formats.

const enum StudioModelFlags {
    AUTOGENERATED_HITBOX           = 0x0001,
    FORCE_OPAQUE                   = 0x0004,
    STATIC_PROP                    = 0x0010,
    CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x2000,
}

export class StudioModelData {
    constructor(renderContext: SourceRenderContext, mdlBuffer: ArrayBufferSlice, vvdBuffer: ArrayBufferSlice, vtxBuffer: ArrayBufferSlice) {
        const mdlView = mdlBuffer.createDataView();

        // Parse MDL header
        assert(readString(mdlBuffer, 0x00, 0x04) === 'IDST');
        const mdlVersion = mdlView.getUint32(0x04, true);
        assert(mdlVersion === 0x2C);

        const mdlChecksum = mdlView.getUint32(0x08, true);

        const name = readString(mdlBuffer, 0x0C, 0x40, true);
        const length = mdlView.getUint32(0x4C, true);

        const eyePositionX = mdlView.getFloat32(0x50, true);
        const eyePositionY = mdlView.getFloat32(0x54, true);
        const eyePositionZ = mdlView.getFloat32(0x58, true);

        const illumPositionX = mdlView.getFloat32(0x5C, true);
        const illumPositionY = mdlView.getFloat32(0x60, true);
        const illumPositionZ = mdlView.getFloat32(0x64, true);

        const moveHullMinX = mdlView.getFloat32(0x68, true);
        const moveHullMinY = mdlView.getFloat32(0x6C, true);
        const moveHullMinZ = mdlView.getFloat32(0x70, true);
        const moveHullMaxX = mdlView.getFloat32(0x74, true);
        const moveHullMaxY = mdlView.getFloat32(0x78, true);
        const moveHullMaxZ = mdlView.getFloat32(0x7C, true);

        const bboxMinX = mdlView.getFloat32(0x80, true);
        const bboxMinY = mdlView.getFloat32(0x84, true);
        const bboxMinZ = mdlView.getFloat32(0x88, true);
        const bboxMaxX = mdlView.getFloat32(0x8C, true);
        const bboxMaxY = mdlView.getFloat32(0x90, true);
        const bboxMaxZ = mdlView.getFloat32(0x94, true);
        const bbox = new AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);

        const flags = mdlView.getUint32(0x98, true);

        const numbones = mdlView.getUint32(0x9C, true);
        const boneindex = mdlView.getUint32(0xA0, true);

        const numbonecontrollers = mdlView.getUint32(0xA4, true);
        const bonecontrollerindex = mdlView.getUint32(0xA8, true);

        const numhitboxsets = mdlView.getUint32(0xAC, true);
        const hitboxsetindex = mdlView.getUint32(0xB0, true);

        const numlocalanims = mdlView.getUint32(0xB4, true);
        const localanimindex = mdlView.getUint32(0xB8, true);

        const numlocalseqs = mdlView.getUint32(0xBC, true);
        const localseqindex = mdlView.getUint32(0xC0, true);
        const activitylistversion = mdlView.getUint32(0xC4, true);
        const eventsindexed = mdlView.getUint32(0xC8, true);

        const numtextures = mdlView.getUint32(0xCC, true);
        const textureindex = mdlView.getUint32(0xD0, true);

        const numcdtextures = mdlView.getUint32(0xD4, true);
        const cdtextureindex = mdlView.getUint32(0xD8, true);

        const numskinref = mdlView.getUint32(0xDC, true);
        const numskinfamilies = mdlView.getUint32(0xE0, true);
        const skinindex = mdlView.getUint32(0xE4, true);

        const numbodyparts = mdlView.getUint32(0xE8, true);
        const bodypartindex = mdlView.getUint32(0xEC, true);

        const numlocalattachments = mdlView.getUint32(0xF0, true);
        const localattachmentindex = mdlView.getUint32(0xF4, true);

        const numlocalnodes = mdlView.getUint32(0xF8, true);
        const localnodeindex = mdlView.getUint32(0xFC, true);
        const localnodenameindex = mdlView.getUint32(0x100, true);

        const numflexdesc = mdlView.getUint32(0x104, true);
        const flexdescindex = mdlView.getUint32(0x108, true);

        const numflexcontrollers = mdlView.getUint32(0x10C, true);
        const flexcontrollerindex = mdlView.getUint32(0x110, true);

        const numflexrules = mdlView.getUint32(0x114, true);
        const flexruleindex = mdlView.getUint32(0x118, true);

        const numikchains = mdlView.getUint32(0x11C, true);
        const ikchainindex = mdlView.getUint32(0x120, true);

        const nummouthss = mdlView.getUint32(0x124, true);
        const mouthsindex = mdlView.getUint32(0x128, true);

        const numlocalposeparameters = mdlView.getUint32(0x12C, true);
        const localposeparamindex = mdlView.getUint32(0x130, true);

        const surfacepropindex = mdlView.getUint32(0x134, true);
        const surfaceprop = readString(mdlBuffer, surfacepropindex);

        const keyvalueindex = mdlView.getUint32(0x138, true);
        const keyvaluesize = mdlView.getUint32(0x13C, true);

        const numlocalikautoplaylocks = mdlView.getUint32(0x140, true);
        const localikautoplaylockindex = mdlView.getUint32(0x144, true);

        const mass = mdlView.getFloat32(0x148, true);
        const contents = mdlView.getUint32(0x14C, true);

        const numincludemodels = mdlView.getUint32(0x150, true);
        const includemodelindex = mdlView.getUint32(0x154, true);

        // Runtime backpointer.
        const virtualModel = mdlView.getUint32(0x158, true);
        assert(virtualModel === 0);

        const animblocknameindex = mdlView.getUint32(0x15C, true);
        const numanimblocks = mdlView.getUint32(0x160, true);
        const animblockindex = mdlView.getUint32(0x164, true);
        const animblockModel = mdlView.getUint32(0x168, true);

        const bonetablebynameindex = mdlView.getUint32(0x16C, true);

        // Runtime backpointer.
        const vertexBase = mdlView.getUint32(0x170, true);
        const indexBase = mdlView.getUint32(0x174, true);
        assert(vertexBase === 0);
        assert(indexBase === 0);

        const constantdirectionallightdot = mdlView.getUint32(0x178, true);
        const rootLOD = mdlView.getUint32(0x179, true);
        const numAllowedRootLODs = mdlView.getUint32(0x17A, true);

        const numflexcontrollerui = mdlView.getUint32(0x180, true);
        const flexcontrollleruiindex = mdlView.getUint32(0x184, true);

        const vertAnimFixedPointScale = mdlView.getFloat32(0x188, true);
        const studiohdr2index = mdlView.getUint32(0x190, true);

        // Parse VVD header
        const vvdView = vvdBuffer.createDataView();

        assert(readString(vvdBuffer, 0x00, 0x04) === 'IDSV');
        const vvdVersion = vvdView.getUint32(0x04, true);
        assert(vvdVersion === 0x04);
        const vvdChecksum = vvdView.getUint32(0x08, true);
        assert(vvdChecksum === mdlChecksum);
        const vvdNumLODs = vvdView.getUint32(0x0C, true);
        const vvdNumLODVertexes = nArray(8, (i) => vvdView.getUint32(0x10 + i * 0x04, true));
        const vvdNumFixups = vvdView.getUint32(0x30, true);
        const vvdFixupTableStart = vvdView.getUint32(0x34, true);
        const vvdVertexDataStart = vvdView.getUint32(0x38, true);
        const vvdTangentDataStart = vvdView.getUint32(0x3C, true);

        // Parse VTX header
        const vtxView = vtxBuffer.createDataView();

        const vtxVersion = vtxView.getUint32(0x00, true);
        assert(vtxVersion === 0x07);

        // VTX optimization settings.
        const vtxCacheSize = vtxView.getUint32(0x04, true);
        const vtxMaxBonesPerStrip = vtxView.getUint16(0x08, true);
        const vtxMaxBonesPerTri = vtxView.getUint16(0x0A, true);
        const vtxMaxBonesPerVert = vtxView.getUint32(0x0C, true);

        const vtxChecksum = vtxView.getUint32(0x10, true);
        assert(mdlChecksum === vtxChecksum);

        const vtxNumLODs = vtxView.getUint32(0x14, true);
        assert(vtxNumLODs === vvdNumLODs);
        const vtxMaterialReplacementListOffset = vtxView.getUint32(0x18, true);
        const vtxNumBodyParts = vtxView.getUint32(0x1C, true);
        assert(vtxNumBodyParts === numbodyparts);
        const vtxBodyPartOffset = vtxView.getUint32(0x20, true);

        // Gather our materials for each LOD.
        // First, gather our base material names.
        const baseMaterialNames: string[] = [];
        let textureIdx = textureindex;
        for (let i = 0; i < numtextures; i++) {
            const nameindex = textureIdx + mdlView.getUint32(textureIdx + 0x00, true);
            const materialName = readString(mdlBuffer, nameindex);
            const flags = mdlView.getUint32(textureIdx + 0x04, true);
            const used = mdlView.getUint32(textureIdx + 0x08, true);
            const unused1 = mdlView.getUint32(textureIdx + 0x0C, true);
            const material = mdlView.getUint32(textureIdx + 0x10, true);
            // This appears to be a stale pointer generated by studiomdl, lol.
            // assert(material === 0);
            const clientmaterial = mdlView.getUint32(textureIdx + 0x14, true);
            assert(clientmaterial === 0);
            baseMaterialNames.push(materialName);
            textureIdx += 0x40;
        }

        const lodMaterialNames: string[][] = [];
        let vtxMaterialReplacementListIdx = vtxMaterialReplacementListOffset;
        for (let i = 0; i < vtxNumLODs; i++) {
            const numReplacements = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x00, true);
            const replacementOffset = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x04, true);

            const materialNames: string[] = baseMaterialNames.slice();
            let replacementIdx = vtxMaterialReplacementListIdx + replacementOffset;
            for (let i = 0; i < numReplacements; i++) {
                const materialID = vtxView.getUint16(replacementIdx + 0x00, true);
                assert(materialID < materialNames.length);
                const nameOffset = replacementIdx + vtxView.getUint32(replacementIdx + 0x04, true);
                const replacementName = readString(vtxBuffer, nameOffset);
                materialNames[materialID] = replacementName;
            }

            lodMaterialNames.push(materialNames);
            vtxMaterialReplacementListIdx += 0x08;
        }

        // We have three separate files of data (MDL, VVD, VTX) to chew through.
        //
        // MDL = Studio Model Header, contains skeleton, most aux data, animations, etc.
        // VVD = Valve Vertex Data, contains actual vertex data.
        // VTX = Optimized Model, contains per-LOD information (index buffer, optimized trilist information & material replacement).

            // The hierarchy of a model is Body Part -> Submodel -> Submodel LOD -> Mesh -> Mesh Group -> Strip
        // Note that "strips" might not actually be tristrips. They appear to be trilists in modern models.

        let mdlBodyPartIdx = bodypartindex;
        let vtxBodyPartIdx = vtxBodyPartOffset;
        for (let i = 0; i < numbodyparts; i++) {
            const bodyPartName = readString(mdlBuffer, mdlBodyPartIdx + mdlView.getUint32(mdlBodyPartIdx + 0x00, true));
            const mdlNumModels = mdlView.getUint32(mdlBodyPartIdx + 0x04, true);
            const mdlBase = mdlView.getUint32(mdlBodyPartIdx + 0x08, true);
            const mdlModelindex = mdlView.getUint32(mdlBodyPartIdx + 0x0C, true);

            const vtxNumModels = vtxView.getUint32(vtxBodyPartIdx + 0x00, true);
            assert(mdlNumModels === vtxNumModels);
            const vtxModelOffs = vtxView.getUint32(vtxBodyPartOffset + 0x04, true);

            let mdlSubmodelIdx = mdlModelindex;
            let vtxSubmodelIdx = vtxBodyPartIdx + vtxModelOffs;
            for (let j = 0; j < mdlNumModels; j++) {
                const mdlSubmodelName = readString(mdlBuffer, mdlSubmodelIdx + 0x00);
                // Never written to.
                // const mdlSubmodelType = mdlView.getUint32(mdlSubmodelIdx + 0x40, true);
                const mdlSubmodelBoundingRadius = mdlView.getFloat32(mdlSubmodelIdx + 0x44, true);
                const mdlSubmodelNumMeshes = mdlView.getUint32(mdlSubmodelIdx + 0x48, true);
                const mdlSubmodelMeshindex = mdlView.getUint32(mdlSubmodelIdx + 0x4C, true);
                const mdlSubmodelNumvertices = mdlView.getUint32(mdlSubmodelIdx + 0x50, true);
                const mdlSubmodelVertexindex = mdlView.getUint32(mdlSubmodelIdx + 0x54, true);
                const mdlSubmodelTangentsindex = mdlView.getUint32(mdlSubmodelIdx + 0x58, true);
                const mdlSubmodelNumattachments = mdlView.getUint32(mdlSubmodelIdx + 0x5C, true);
                const mdlSubmodelAttachmentindex = mdlView.getUint32(mdlSubmodelIdx + 0x60, true);
                const mdlSubmodelNumeyeballs = mdlView.getUint32(mdlSubmodelIdx + 0x64, true);
                const mdlSubmodelEyeballindex = mdlView.getUint32(mdlSubmodelIdx + 0x68, true);

                // mstudio_modelvertexdata_t
                const mdlSubmodelVertexDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x70, true);
                assert(mdlSubmodelVertexDataPtr === 0);
                const mdlSubmodelTangentsDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x74, true);
                assert(mdlSubmodelTangentsDataPtr === 0);

                // int unused[8];

                const vtxSubmodelNumLODs = vtxView.getUint32(vtxSubmodelIdx + 0x00, true);
                assert(vtxSubmodelNumLODs === vtxNumLODs);
                const vtxSubmodelLODOffset = vtxView.getUint32(vtxSubmodelIdx + 0x04, true);

                // TODO(jstpierre): Support multiple model LODs. For now, we only support the first model.

                mdlSubmodelIdx += 0x98;
                vtxSubmodelIdx += 0x08;
            }

            mdlBodyPartIdx += 0x10;
            vtxBodyPartIdx += 0x08;
        }
    }

    public destroy(device: GfxDevice): void {
    }
}

export class StudioModelCache {
    private modelData = new Map<string, StudioModelData>();
    private modelDataPromiseCache = new Map<string, Promise<StudioModelData>>();

    constructor(private renderContext: SourceRenderContext, private filesystem: SourceFileSystem) {
    }

    private resolvePath(path: string, ext: string): string {
        if (path.endsWith('.mdl'))
            path = path.slice(0, -4);
        if (!path.endsWith(ext))
            path = `${path}${ext}`;
        return this.filesystem.resolvePath(path);
    }

    private async fetchStudioModelDataInternal(name: string): Promise<StudioModelData> {
        const mdlPath = this.resolvePath(name, '.mdl');
        const vvdPath = this.resolvePath(name, '.vvd');
        const vtxPath = this.resolvePath(name, '.dx90.vtx');
        const [mdlBuffer, vvdBuffer, vtxBuffer] = await Promise.all([
            this.filesystem.fetchFileData(mdlPath),
            this.filesystem.fetchFileData(vvdPath),
            this.filesystem.fetchFileData(vtxPath),
        ]);
        return new StudioModelData(this.renderContext, mdlBuffer!, vvdBuffer!, vtxBuffer!);
    }

    public fetchStudioModelData(path: string): Promise<StudioModelData> {
        if (!this.modelDataPromiseCache.has(path))
            this.modelDataPromiseCache.set(path, this.fetchStudioModelDataInternal(path));
        return this.modelDataPromiseCache.get(path)!;
    }

    public destroy(device: GfxDevice): void {
        for (const vtf of this.modelData.values())
            vtf.destroy(device);
    }
}